# Base record set for an EVR

record(bo, "$(P)enable") {
  field(DTYP, "EVR")
  field(OUT , "@C=$(C), P=Enable")
  field(DESC, "Master enable for EVR device")
  field(MASK, "1")
  field(ZNAM, "Disabled")
  field(ONAM, "Enabled")
  info(autosaveFields_pass0, "VAL")
}

record(longin, "$(P)link:timo") {
  field(DTYP, "EVR")
  field(INP , "@C=$(C), P=HB Timeout Count")
  field(SCAN, "I/O Intr")
  field(DESC, "# of heartbeat timeout")
}

record(bi, "$(P)link:sts") {
  field(DTYP, "EVR")
  field(INP , "@C=$(C), P=Link Status")
  field(DESC, "Status of event link")
  field(SCAN, "1 second")
  field(ZNAM, "Fail")
  field(ONAM, "OK")
  field(ZSV , "MAJOR")
  field(FLNK, "$(P)link:cnt")
}

record(longin, "$(P)link:cnt") {
  field(DTYP, "EVR")
  field(DESC, "Receive Error Count")
  field(INP , "@C=$(C), P=Receive Error Count")
  field(DESC, "Rx error count")
  field(TSEL, "$(P)link:sts.TIME")
  field(FLNK, "$(P)fifo:cnt")
}

record(longin, "$(P)fifo:cnt") {
  field(DTYP, "EVR")
  field(DESC, "FIFO Overflow Count")
  field(INP , "@C=$(C), P=FIFO Overflow Count")
  field(DESC, "Rx error count")
  field(TSEL, "$(P)link:cnt.TIME")
  field(FLNK, "$(P)link:sts:init")
}

# Detect the first time the event link
# is online.  Then set master enable.
record(calcout, "$(P)link:sts:init") {
  field(DESC, "Detect initial link up")
  field(INPA, "$(P)link:sts")
  field(CALC, "A")
  field(OUT , "$(P)enable PP")
  field(OOPT, "Transition To Non-zero")
  field(ODLY, "1.0")
  field(TSEL, "$(P)link:sts.TIME")
}

record(ao, "$(P)clock:set") {
  field(DTYP, "EVR")
  field(OUT , "@C=$(C), P=Clock")
  field(PINI, "YES")
  field(DESC, "Event Link speed")
  field(VAL , "124.916")
  field(EGU , "MHz")
  field(LINR, "LINEAR")
  field(ESLO, "1e-6")
  field(HOPR, "150")
  field(LOPR, "50")
  field(DRVH, "150")
  field(DRVL, "50")
  field(PREC, "3")
  field(FLNK, "$(P)clock")
  info(autosaveFields_pass0, "VAL EGU ESLO HOPR LOPR DRVH DRVL PREC")
}

record(ai, "$(P)clock") {
  field(DTYP, "EVR")
  field(INP , "@C=$(C), P=Clock")
  field(DESC, "Event Link speed")
  field(PINI, "YES")
  field(UDF , "0")
  field(EGU , "MHz")
  field(LINR, "LINEAR")
  field(ESLO, "1e-6")
  field(PREC, "3")
  field(FLNK, "$(P)clock:error")
  info(autosaveFields_pass0, "EGU ESLO HOPR LOPR PREC")
}

record(calc, "$(P)clock:error") {
  field(CALC, "(A-B)*1000")
  field(EGU , "KHz")
  field(PREC, "3")
  field(INPA, "$(P)clock:set")
  field(INPB, "$(P)clock")
  field(TSEL, "$(P)clock.TIME")
  field(FLNK, "$(P)clock:period")
  info(autosaveFields_pass0, "EGU CALC PREC")
}

# Intended for use in calculations
record(calc, "$(P)clock:period") {
  field(DESC, "Event period")
  field(CALC, "B/A")
  field(EGU , "s")
  field(PREC, "3")
  field(INPA, "$(P)clock:set")
  field(INPB, "$(P)clock:set.ESLO")
  field(TSEL, "$(P)clock.TIME")
}

record(bi, "$(P)pll") {
  field(DTYP, "EVR")
  field(INP , "@C=$(C), P=PLL Lock Status")
  field(SCAN, "1 second")
  field(PINI, "YES")
  field(DESC, "Status of PLL")
  field(ZNAM, "Error")
  field(ONAM, "OK")
  field(ZSV , "MAJOR")
}

record(longin, "$(P)hwtype") {
  field(DTYP, "EVR")
  field(INP , "@C=$(C), P=Model")
  field(PINI, "YES")
  field(DESC, "Hardware type code")
}

record(longin, "$(P)ver") {
  field(DTYP, "EVR")
  field(INP , "@C=$(C), P=Version")
  field(PINI, "YES")
  field(DESC, "Firmware version")
}

record(fanout, "$(P)ts:init") {
  field(PINI, "YES")
  field(LNK1, "$(P)ts:clock:set")
  field(LNK2, "$(P)ts:source")
}

record(bi, "$(P)ts:valid") {
  field(DTYP, "EVR")
  field(INP , "@C=$(C), P=Timestamp Valid")
  field(SCAN, "I/O Intr")
  field(ZSV , "MAJOR")
  field(ZNAM, "Invalid")
  field(ONAM, "Valid")
}

record(mbbo, "$(P)ts:source") {
  field( DTYP, "Raw Soft Channel")
  field( OUT , "$(P)ts:source:raw")
  field( PINI, "YES")
  field( ZRST, "Event clock")
  field( ONST, "Mapped code(s)")
  field( TWST, "DBus 4")
  field( ZRVL, "0")
  field( ONVL, "1")
  field( TWVL, "2")
  field( THSV, "INVALID")
  field( FRSV, "INVALID")
  field( FVSV, "INVALID")
  field( SXSV, "INVALID")
  field( SVSV, "INVALID")
  field( EISV, "INVALID")
  field( NISV, "INVALID")
  field( TESV, "INVALID")
  field( ELSV, "INVALID")
  field( TVSV, "INVALID")
  field( TTSV, "INVALID")
  field( FTSV, "INVALID")
  field( FFSV, "INVALID")
  field( UNSV, "INVALID")
  field( IVOA, "Don't drive outputs")
  field(FLNK, "$(P)ts:source:raw")
  info(autosaveFields_pass0, "VAL")
}

record(longout, "$(P)ts:source:raw") {
  field(DTYP, "EVR")
  field(OUT , "@C=$(C), P=Timestamp Source")
  field(FLNK, "$(P)ts:clock")
}

record(ao, "$(P)ts:clock:set") {
  field(DTYP, "EVR")
  field(OUT , "@C=$(C), P=Timestamp Clock")
  field(DESC, "Timestamp speed")
  field(VAL , "10.0")
  field(EGU , "MHz")
  field(LINR, "LINEAR")
  field(ESLO, "1e-6")
  field(HOPR, "150")
  field(LOPR, "1")
  field(DRVH, "150")
  field(DRVL, "1")
  field(PREC, "3")
  field(FLNK, "$(P)ts:clock")
  info(autosaveFields_pass0, "VAL EGU ESLO HOPR LOPR DRVH DRVL PREC")
}

record(ai, "$(P)ts:clock") {
  field(DTYP, "EVR")
  field(INP , "@C=$(C), P=Timestamp Clock")
  field(SCAN, "1 second")
  field(DESC, "Timestamp speed")
  field(PINI, "YES")
  field(UDF , "0")
  field(EGU , "MHz")
  field(LINR, "LINEAR")
  field(ESLO, "1e-6")
  field(PREC, "3")
  field(FLNK, "$(P)ts:div")
}

record(longin, "$(P)ts:div") {
  field(DTYP, "EVR")
  field(INP , "@C=$(C), P=Timestamp Prescaler")
  field(DESC, "Timestamp divider")
}

record(stringin, "$(P)ts") {
  field(DTYP, "EVR Timestamp")
  field(INP , "@C=$(C)")
  field(SCAN, "Event")
  field(EVNT, "$(EVNT1HZ)")
}

