
/////////
Compile with asciidoc
http://www.methods.co.nz/asciidoc/
/////////

MRF EVR Usage Guide
===================
:Author:    Michael Davidsaver
:Email:     mdavidsaver@bnl.gov
:Date:      May 2010
:Revision:  2
:Key words: epics, ioc, device support, mrf, timing

== Overview ==

The purpose of this document is to act as a guide and reference
when using the 'mrfioc2' EPICS device support for the Micro Research
Finland (MRF) timing Event Receiver (EVR).
Usage of the Event Generator (EVG) is described elsewhere.

The MRF Event Timing System can be deployed in two configurations.
The first is a unidirectional broadcast from a single source (EVG) to multiple
destinations (EVRs).
The Repeater devices are simply retransmits the its single input to all outputs.
In the second configuration a return patch from many EVRs back up to a central
(master) EVR is added.

An EVR will act in one of two roles: either Leaf or Master.
All, or all but one, EVR will be in the Leaf role.
The special Master EVR acts as the termination point for events
and data on the upstream path.

The Master EVR is necessary because, while the generator (EVG) is capable of
receiving an event stream, it does not impliment most of the features of the
receiver (EVR).

[[mrf_overview]]
.Two system configurations for the MRF Timing System
image::images/mrf-overview.png[]

What is transmitted over the event link is a combination of 8-bit event
codes and data.
Data can take the form of a single 8-bit byte which is simply copied from sender
to receiver (Distributed Bus or DBus), and optionally a variable length byte
array (Data Buffer).

These two types of data can be combined in two ways depending on whether or not
the data buffer transmission feature is used.
In configuration A every 16-bit frame is split between an 8-bit event and
the 8-bit Distributed Bus.
In configuration B every frame carries an 8-bit event with the Distributed Bus
and Data Buffer sent in alternating frames.

In addition to data, the use of 8b10b encoding on the event link allows the
local oscillator of each EVR to be phase locked to the master on the EVG.

[[mrf_frames]]
.Two supported link allocation schemes
image::images/mrf-frames.png[]

Internally an EVR can be thought of a number of logical sub-units connected
to the up- and down- stream event links, and to the local inputs and outputs
of the EVR.
These sub-units include: the Event Mapping Ram, Pulse Generators,
Prescalers (clock dividers), and the logical controls for the physical
inputs and outputs.

[[evr_blocks]]
.Logical connections inside an EVR
image::images/mrf-evr-blocks.png[]

=== Pulse Generators ===

Each pulse generator has a an associated delay, width, polarity
(active low/high), and (sometimes) a prescaler (clock divider).
When triggered by the Mapping Ram it will wait for a set time in its inactive state (delay).
Then it will transition to its active state, wait another set time (width)
before transitioning back to its inactive state.

In addition, the Mapping Ram can force a Pulse Generator into either state (Set/Reset).

Note: Some Pulse Generators do not have a prescaler.  In this case the prescaler
      property will always read 0 instead of >=1.

=== Event Mapping Ram ===

The Event Mapping Ram is a table used to define the actions to be taken by
an EVR when it receives a certain event code number.
The mapping it defines is a many-to-many relations.
One event can cause several actions, and one action can be caused by
several events.

The actions which can be taken can be grouped into two catagories:
Special actions, and Pulse Generator actions.
Special actions include those related to timestamp distribution, and
the system heartbeat tick.
Each Pulse Generater has three mapable actions: Set (force active), Reset (force inactive), and Trigger (start delay program).  Most applications will use Trigger
mappings.

=== Prescalers (Clock Divider) ===

Prescaler sub-units take the local system clock frequency and output a
lower frequency clock which is phased locked to the local clock,
which is in sync with the global master clock.
The lower frequency will be an integer divisor of the system clock.

=== Outputs (TTL) ===

This sub-unit represents a local physical output on the EVR.
Each output may be connected to one source: a Distributed Bus bit,
a Prescaler, or a Pulse Generator.


=== Outputs (CML) ===

Current Mode Logic outputs can send a bit pattern at the bit rate of the event link (20x the Event Clock).
This pattern may be specified in one of three possible ways.

. As four 20 bit sub-patterns (rising, high, falling, and low).  The rising and falling patterns are transmitted when the output level changes, while the high and low patterns are repeated until the level changes.
. As two times (high and low).  These specify a square wave with variable frequency and duty factor.
. As an arbitrary bit pattern (<= 40940 bits) which begins when the output goes [TODO: high or low?].

=== Inputs ===

An input can cause several actions when triggered by a local signal.
It may be directly connected to one of the upstream Distributed Bus bits,
it may cause an event to be sent on the upstream links, or applied
to the local Mapping Ram.

=== Global Timestamp Reception ===

Each EVR receives synchronous time broadcasts from an EVG.
The driver may query the current time at any point.
The arrival time of certain event codes can be saved as well.
This can be accomplished with the 'event' record device support.

=== Data Buffer Tx/Rx ===

When the event system is configured to share the data byte of each frame EVR can receive
data broadcasts from an EVG and/or send data back to the master EVR.
Each data block has a one byte header (Protocol ID) used to identify interested recipients.

Recipients will register callback functions.

The default recipient stores data in a waveform record.

== What is Available? ==

More infomation on the Micro Research hardware can be found on their
website http://www.mrf.fi/[http://www.mrf.fi/].

The software discussed below can be found on the EPICS application
project on SourceForge http://sourceforge.net/projects/epics/[http://sourceforge.net/projects/epics/].

The latest developments can be found in the 'mrfioc2' Mercuial VCS repository.

http://epics.hg.sourceforge.net/hgweb/epics/mrfioc2/summary[http://epics.hg.sourceforge.net/hgweb/epics/mrfioc2/summary]

=== Prerequisites ===

Requires EPICS Base (>= 3.14.8.2), and the MSI tool.  Supported on RTEMS >= 4.9.x, vxWorks >=6.7, and Linux >= 2.6.26.

Base: http://www.aps.anl.gov/epics/base/R3-14/index.php[http://www.aps.anl.gov/epics/base/R3-14/index.php]

MSI: http://www.aps.anl.gov/epics/extensions/msi/index.php[http://www.aps.anl.gov/epics/extensions/msi/index.php]

The Mercurial VCS tool is needed to checkout the development repository.

Mercuial: http://mercurial.selenic.com/[http://mercurial.selenic.com/]

=== The Source ===

VCS Checkout

-----------------------------------------------------------------------
$ hg checkout http://epics.hg.sourceforge.net:8000/hgroot/epics/mrfioc2
-----------------------------------------------------------------------

Edit 'configure/CONFIG_SITE' and run "make".

The following is a brief tour of the important locations in the source tree
relating to the EVR.

==== mrfCommon ====

Some support functions.  Contains 'mrfCommonIO.h' which devices macros
for access to memory mapped IO.  Also the support a library and CLI utilities
for en/decoding the control word for the fractional synthesizer used on
EVRs and EVGs.

==== pciApp ====

OS independent abstraction for working with PCI devices.

==== vmeApp ====

OS independent abstraction for working with VME64x devices.

==== mrmShared ====

Contains code shared with the EVG.
This includes data buffer transmission.

Also contains the Linux kernel driver stub to allow userspace PCI operations.

==== evrApp ====

The MRF IOC has a strong seperation between device and driver support.
The device support and interface definition are in this module.
The interface is defined by the C++ abstract base classes in 
'evrApp/src/evr/'.
A set of device support routines using is found in 'evrApp/src/dev*.cpp'.
Some generic database files are found in 'evrApp/Db/'.

==== evrMrmApp ====

The is the driver for the Modular Register Map (MRM) firmware
version for the EVR.
It provides a concrete implimentation of the abstract classes defined
in 'evrApp'.
It also provided IOC shell functions to instanciate a device in
'evrMrmApp/src/drvemIocsh.cpp'.
'evrMrmApp/Db/evr-*.substitutions' will create a complete example
database.
An example IOC using the database is in 'iocBoot/iocevrmrm/'.

== Supported Hardware ==

The following devices are supported.

=== VME EVR 230 (non-RF) ===

Outputs: Front panel: 4, Front Panel UNIV. 2
Inputs: Front panel: 2

Supports the VME rear transition module.

=== VME EVR 230 (RF) ===

Similar to the non-RF version, but front panel outputs 4, 5, and 6
are CML outputs.

DB template: evr-vmerf-230.substitiutions

=== PMC EVR 230 ===

A PCI Mezzanine Card with one front panel input and two front panel outputs.

Outputs: Front panel: 2
Inputs: Front panel: 1

DB template: evr-pmc-230.substitiutions

=== cPCI EVR 230 ===

A compact PCI Card.

Outputs: Front panel universal: 4
Inputs: Front panel: 2

Supports the side-by-side expansion module.

DB template: evr-cpci-230.substitiutions

== IOC Deployment ==

This section outlines a general strategy for adding an EVR to an IOC.
First general information is presented, followed by a section
describing the extra steps needed to use mrfioc2 under Linux.

=== VME64x Device Configuration ===

The VME bus based EVRs are configured using the mrmEvrSetupVME() IOC shell function.

-----------------------------------------
mrmEvrSetupVME(1,5,0x20000000,3,0x26)
-----------------------------------------

In this example EVR #1 is defined to be the VME card in slot 5.
It is given the A32 base address of 0x20000000 and configured to
interrupt on level 3 with vector 0x26.

Note::
  VME64x allows for jumpless configuration of the card, but can not automatically assign
  resources.  Selection of an unused address range and IRQ level/vector is therefore
  left to the user.

Note::
  Before setup is done the VME64 identifer fields are verified so that
  specifying an incorrect slot number is detected and setup will safely abort.

=== PCI Device Configuration ===

PCI bus cards are identified with the mrmEvrSetupPCI() IOC shell function.

Since PCI devices are automatically configured only the geographic address (bus:device.function)
needs to be provided.
This information can usually be found at boot time (RTEMS) or in /proc/bus/pci/devices (Linux).

The IOC shell function devPCIShow() is also provided to list PCI devices in the system.

-----------------------------------------
mrmEvrSetupPCI(0,1,2,0)
-----------------------------------------

This example defines EVR #0 to be bus 1 device 2 function 0.

Note::
  Before setup is done the PCI identifer fields are verified so that
  specifying an incorrect location is detected and setup will safely abort.

=== Example Databases ===

The MRFIOC2 includes example database templates several devices (see the supported hardware section).
While fully functional it is expected that most sites will modify
them.  It is suggested that the original be left unchanged and a copy be made
with the institute name and other information as a suffix.
(evr-pmc-230.substitutions becomes evr-pmc-230-nsls2.substitutions).

The authors would like to encouraged users to submit their customized databases back
so that they may be included as examples in future releases of MRFIOC2.

The templates consist of a substitutions file for each model (PMC, cPCI, VME-RF).
This template instanciates the correct number of records for the number of inputs/outputs
found on each device.
It also includes entries for event mappings and database events which will be frequent
targets for customization.

Each substitutions file will be expanded during the build process with the MSI utility
to create a database file with two undefined macros (P and C).
'P' is the common prefix shared by all pvs and must be unique in the system.
'C' is a card number also given as the first argument of one of the mrmEvrSetup*() IOC shell functions (unique in each IOC).

Thus an IOC with two identical VME cards could use a configuration like:

------------------------------------------------------
mrmEvrSetupVME(1,5,0x20000000,3,0x26)
mrmEvrSetupVME(2,6,0x21000000,3,0x28)

dbLoadRecords("evr-vmerf-230.db", "P=test:evra:, C=1")
dbLoadRecords("evr-vmerf-230.db", "P=test:evrb:, C=2")
------------------------------------------------------


=== PCI Setup in Linux ===

In order to use PCI EVRs in the Linux operating system a small kernel driver must be built and loaded.
The source for this driver is found in 'mrmShared/linux'.
This directory contains a Makefile for use by the Linux kernel build system (not EPICS).

To build the driver you must have access to a configured copy of the kernel source used to build the
kernel into which the driver will be loaded.  If the build and host systems are the same then the
default location will likely be '/lib/modules/`uname -r`/build'.  In case of a cross-built kernel
the location will be elsewhere.

To build the module for use on the host computer:

----------------------------------------------------------------------------------------------
$ make -C /location/of/mrmShared/linux KERNELDIR=/lib/modules/`uname -r`/build modules_install
$ sudo depmod -a
$ sudo modprobe mrf
----------------------------------------------------------------------------------------------

Building for a cross-target might look like:

----------------------------------------------------------------------------------------------
$ make -C /location/of/mrmShared/linux KERNELDIR=/location/of/kernel/src \
  ARCH=arm CROSS_COMPILE=/usr/local/bin/arm- INSTALL_MOD_PATH=/location/of/target/root
----------------------------------------------------------------------------------------------

Once the module is installed you must create the special device file associated with each EVR.
If your target system is running UDEV this may happen automatically, if not then you must do the
following.

-------------------------------------
# grep mrf /proc/devices
254 mrf
# mknod -m 666 /dev/uio0 c 254 0
-------------------------------------

Each additional device adds one to the minor number.

Once the device file exists with the correct permissions the IOC will be able to location it
based on the bus:device.function given an to mrmEvrSetupPCI().

Note::
  UIO numbers are not considered during setup since these may change after a reboot.
  To unsure repeatability only PCI immutable ID fields and the address triplet (bus:device.function) are used.

== Device Support Design ==

The EPICS device support package for EVRs consists of a number of supports
which are generally tied to a specific logical sub-unit.
Each sub-unit may be thought of as having a number of properties.
For example a Delay Generator has properties 'Delay' and 'Width'.
These properties can be set in several ways.
A delay can specified as an integer number of ticks of its reference
clock (hardware view), or in seconds as a floating point number (user view).

In this example the properties 'Delay' and 'Width' should be settable in
exact integer as well as the more useful, but inexact, units of seconds.
This needs to be accomplish by two different device supports (longout,
and ao).
Of course it is also useful to have some confirmation that settings
have been applied so read-backs are desireable (longin, ai).

To this end the Pulser impliments the following device supports.

-------------------------------------------------------
# Pulser devices
# '@C=cardid, I=pulserid, P=property'
device(longin,     INST_IO, devLIPulser, "EVR Pulser")
device(longout,    INST_IO, devLOPulser, "EVR Pulser")
device(ai,         INST_IO, devAIPulser, "EVR Pulser")
device(ao,         INST_IO, devAOPulser, "EVR Pulser")
device(bi,         INST_IO, devBIPulser, "EVR Pulser")
device(bo,         INST_IO, devBOPulser, "EVR Pulser")
-------------------------------------------------------

Since the Pulser sub-unit has the property 'Delay'
which supports both integer and float settings,
the following database can be constructed.

--------------------------------------------
record(ao, "$(P)$(N)delay:set") {
  field(DTYP, "EVR Pulser")
  field(OUT , "@C=$(C), I=$(PID), P=Delay")
  field(PINI, "YES")
  field(DESC, "Pulse Generator $(PID)")
  field(VAL , 0)
  field(EGU , "uSec")
  field(LINR, "LINEAR")
  field(ESLO, 1e6)
  field(PREC, 6)
  field(FLNK, "$(P)$(N)delay")
}

record(longout, "$(P)$(N)delay:set:raw") {
  field(DTYP, "EVR Pulser")
  field(OUT , "@C=$(C), I=$(PID), P=Delay")
  field(FLNK, "$(P)$(N)delay")
}

record(ai, "$(P)$(N)delay") {
  field(DTYP, "EVR Pulser")
  field(INP , "@C=$(C), I=$(PID), P=Delay")
  field(UDF , 0)
  field(EGU , "uSec")
  field(LINR, "LINEAR")
  field(ESLO, 1e6)
  field(PREC, 6)
  field(FLNK, "$(P)$(N)delay:raw")
}

record(longin, "$(P)$(N)delay:raw") {
  field(DTYP, "EVR Pulser")
  field(INP , "@C=$(C), I=$(PID), P=Delay")
}
--------------------------------------------

This provides "raw" and "cooked" setting and readback
for the delay property.

It is generally inadvisible to have both "raw" and "cooked"
settings in a production database unless steps are taken to
synchronize them.

== Device Support Reference ==

The following sections list the properties for all sub-units
with functional descriptions.

=== Global ===

Properties in this section apply to the EVR as a whole.

Records accessing properties in this section will have DTYP
set to "EVR".

See: evrApp/Db/evrbase.db

==== Enable ====

Implimented for: bo, bi

Master enable for the EVR.
If not set then very little will happen.

==== PLL Lock Status ====

Implimented for: bi

This indicates whether the phase locked loop which synchronizes
an EVR's local oscilator with the phase of the EVG's oscilator.

Except for immediately after a change to the fractional synthesizer
this should always read as true (locked).

==== Link Status ====

Implimented for: bi

Indicates that the event link is active.
This means that the receiver sees light, that the phase is locked,
and that valid data is being received from the EVG.

A reading of false may be caused by a number of conditions including:
EVG down, fiber unplugged or broken, and/or incorrent fractional synthesizer
setting.

==== Model ====

Implimented for: longin

The hardware model number.

==== Version ====

Implimented for: longin

The firmware version.

==== Clock ====

Implimented for: ao, ai

Frequency of an EVR's local oscilator.
This must be close enough to the EVG master oscilator
to allow the phase locked loop to lock.

The native analog units are Hertz (Hz).
This can be changed with the LINR and ESLO fields.
Use ESLO of 1e-6 to allow user setting/reading in MHz.

==== Timestamp Source ====

Implimented for: longout, longin

Determines what causes the timestamp event counter to tick.
There are three possible values.

"Event clock" (0) uses an integer divisor of the EVR's local oscilator.

"Mapped code(s)" (1) increments the counter whenever certain events arrive.
These codes can be defined using special mapping records.

"DBus 4" uses increments on the 0->1 transition of DBus bit #4.

==== Timestamp Clock ====

Implimented for: ao, ai

Specifies the rate at which the timestamp event counter will be incremented.
This determines the resolution of all timestamps.

This setting is used in conjunction with the 'Timestamp Source'.

When the timestamp source is set to "Event clock" this property
is used to compute an integer divider from the EVR's local oscilator
frequency to the given frequency.  Since this may not be exact it is
possible to read back the actual divider setting via the
"Timestamp Prescaler" property.

In all modes this value is used to convert the timestamp event counter
values from ticks to seconds.

By default the analog units are Hertz (Hz).
This can be changed with the LINR and ESLO fields.
Use ESLO of 1e-6 to allow user setting/reading in MHz.

==== Timestamp Prescaler ====

Implimented for: longin

When using the "Event clock" timestamp source this will return the actual
divisor used.  In other modes it reads 0.

==== Timestamp ====

Implimented for: stringin

When processed creates a human readable string with either the current
event link time, or the event link time when code # was last received.

==== Event Clock TS Div ====

Implimented for: longin

This is an approximate divider from the event link frequency down to
1MHz.  It is used to determine the heartbeat timeout.

==== Receive Error Count ====

Implimented for: longin

Counts the number of event link errors which occur.



=== Pulse Generator ===

Properties in this section apply to the Pulse Generator (Pulser) sub-unit.

Records accessing properties in this section will have DTYP
set to "EVR Pulser".

See: evrApp/Db/evrpulser.db

==== Enable ====

Implimented for: bo, bi

When not set the output of the Pulse Generator will remain in its
inactive state (normally low).
It must be set before mapped actions will have any effect.

==== Polarity ====

Implimented for: bo, bi

Reverses the output polarity.
When set, changes the Pulse Generator's output from normally low
to normally high.

==== Prescaler ====

Implimented for: longout, longin

Increses the resolution of both delay and width by an integer multiple.
Determines the tick rate of the down counters used for delay and width
with respect to the EVR's local oscillator.

==== Delay ====

Implimented for: ao, longout, ai, longin

Determines the time between when the Pulse Generator is triggered
and when it changes state from inactive to active (normally low to high).

This can be given in integer ticks, or floating point seconds.
This can be changed with the LINR and ESLO fields.
Use ESLO of 1e6 to allow user setting/reading in microseconds.

==== Width ====

Implimented for: ao, longout, ai, longin

Determines the time between when the Pulse Generator changes state
from inactive to active (normally low to high), and when it changes
back to inactive.

This can be given in integer ticks, or floating point seconds.
This can be changed with the LINR and ESLO fields.
Use ESLO of 1e6 to allow user setting/reading in microseconds.



=== Prescaler (Clock Divider) ===

Properties in this section apply to the Prescaler sub-unit.

Records accessing properties in this section will have DTYP
set to "EVR Prescaler".

See: evrApp/Db/evrscale.db

==== Divide ====

Implimented for: longout, ao, longin

Sets the integer divisor between the Event Clock and the sub-unit output.

By default the analog units are Hertz (Hz).
This can be changed with the LINR and ESLO fields.
Use ESLO of 1e-6 to allow user setting/reading in MHz.



=== Output (TTL and CML) ===

Properties in this section apply to the Output sub-unit.

Records accessing properties in this section will have DTYP
set to "EVR Output".

See: evrMrmApp/Db/mrmevrout.db

==== Map ====

Implimented for: longout, longin

The meaning of this value is determined by the specific implimentation used.

For the MRM implimentation the following codes are valid.

[width="30%",cols="1,5",options="header"]
|==========================
|#  |Output Source
|63 |Force High
|62 |Force Low
|42 |Prescaler (Divider) 2
|41 |Prescaler (Divider) 1
|40 |Prescaler (Divider) 0
|39 |Distributed Bus Bit 7
|38 |Distributed Bus Bit 6
|37 |Distributed Bus Bit 5
|36 |Distributed Bus Bit 4
|35 |Distributed Bus Bit 3
|34 |Distributed Bus Bit 2
|33 |Distributed Bus Bit 1
|32 |Distributed Bus Bit 0
| 9 |Pulse generator 9
| 8 |Pulse generator 8
| 7 |Pulse generator 7
| 6 |Pulse generator 6
| 5 |Pulse generator 5
| 4 |Pulse generator 4
| 3 |Pulse generator 3
| 2 |Pulse generator 2
| 1 |Pulse generator 1
| 0 |Pulse generator 0
|==========================

=== Output (CML only) ===

Additional properties for Current Mode Logic (CML) outputs.

Records accessing properties in this section will have DTYP
set to "EVR CML" with the exception of waveform records which have either "EVR CML Pattern Set" or "EVR CML Pattern Get".

See: evrApp/Db/evrcml.db

==== Enable ====

Implimented for: bo, bi

Trigger permit.

==== Power ====

Implimented for: bo, bi

Current on.

==== Reset ====

Implimented for: bo, bi

Pattern reset.

==== Mode ====

Implimented for: mbbo

Selects CML pattern mode.  Possible values are: 4x Pattern (0), Frequency (1), Waveform (2).

4x Pattern::
  Uses the Pat Rise, Pat High, Pat Fall, and Pat Low properties to store four 20 bit (0 -> 0xfff) sub-patterns.

Frequency::
  Uses the Freq Trig Lvl, Counts High, and Counts Low properties

Waveform::
  Uses the bit pattern stored by the Pattern Set property.

==== Pat Rise/High/Fall/Low ====

Implimented for: longout, longin

Each property stores a seperate 20-bit pattern (0 -> 0xfff).
These patterns are sent during the four parts of a square wave.

Rising and Falling patterns start as soon as the edge is detected and will interrupt
the pattern currently being sent.

The High and Low patterns are sent after an edge pattern is sent and will repeat
until the next edge.

==== Freq Trig Lvl ====

Implimented for: bo, bi

Synchronize forces to this level when in frequency mode.

==== Counts High/Low ====

Implimented for: longout, longin, ao, ai

Stores a value (>20) which is the number of counts (long) or time (analog) of the high or low part of a square wave.

=== Input ===

Properties in this section apply to the Input sub-unit.

Records accessing properties in this section will have DTYP
set to "EVR Input".

See: evrApp/Db/evrin.db

==== Active Level ====

Implimented for: bo, bi

When operating in level triggered mode,
determines if codes are sent when the input level is low, or high.

==== Active Edge ====

Implimented for: bo, bi

When operating in edge triggered mode,
Determines if codes are sent on the falling or rising edge in the
input signal.

==== External Mode ====

Implimented for: mbbo, mbbi

Selects the condition (Level, Edge, None) in which to inject event
codes into the local mapping ram.
These codes are treated as codes coming from the downstream event link.

==== External Code ====

Implimented for: longout, longin

Sets the code which will be applied to the local mapping ram whenever
the 'External Mode' condition is met.

==== Backwards Mode ====

Implimented for: mbbo, mbbi

Selects the condition (Level, Edge, None) in which to send on
the upstream event link.

==== Backwards Code ====

Implimented for: longout, longin

Sets the code which will be sent on the upstream event link whenever
the 'Backwards Mode' condition is met.

==== DBus Mask ====

Implimented for: mbbo, mbbi

Sets the upstream Distributed Bus bit mask which is driven by this
input.


=== Event Mapping ===

Properties in this section describe actions which should be taken when
an event code is received.

==== Pulse Generator Mapping ====

Implimented for: longout

See: evrApp/Db/evrpulsermap.db

Causes a received event to trigger
a Pulse Generator (Pulser) sub-unit, or force it into
an active (set) or inactive (reset) state.

These records will have DTYP set to "EVR Pulser Mapping".

Each record will cause one event to trigger, set, or reset one
Pulse Generator.
It is possible (and likely) that more then one record will interact
with each event code or Pulse Generator.
However, each pairing must be unique.

-------------------------------------------
record(longout, "$(P)$(N)$(M)") {
  field( DTYP, "EVR Pulser Mapping" )
  field( OUT , "@C=$(C), I=$(PID), Func=S$(F)")
  field( PINI, "YES")
  field( DESC, "Mapping for Pulser $(PID)")
  field( VAL , "$(EVT)")
  field( LOPR, "0")
  field( HOPR, "255")
}
-------------------------------------------

In this example the event '$(EVT)' in the 'VAL' field will cause
function '$(F)' on Pulse Generator '$(PID)'.
Current functions are 'Trig', 'Reset', and 'Set'.

==== Special Function Mapping ====

Implimented for: longout

See: evrApp/Db/evrmap.db

Allows a number of special actions to be mapped to certains events.
These actions include:

Blink::
  An LED on the EVRs front panel will blink when the code is received.

Forward::
  The received code will be immediately retransmits on the upstream
  event link.

Stop Log::
  Freeze the circular event log buffer.  An CPU interrupt will be
  raised which will cause the buffer to be downloaded.
  This might be a useful action to map to a fault event.

Log::
  Include this event code in the circular event log.

Heartbeat::
  This event resets the heartbeat timeout timer.

Reset PS::
  Resets the phase of all prescalers.

TS reset::
  Transfers the seconds timestamp from the shift register and zeros
  the sub-seconds part.

TS tick::
  When the timestamp source is 'Mapped code' then any event with
  this mapping will cause the sub-seconds part of the timestamp
  to increment.

Shift 1::
  Shifts the current value of the seconds timestamp shift register
  up by one bit and sets the low bit to 1.

Shift 0::
  Shifts the current value of the seconds timestamp shift register
  up by one bit and sets the low bit to 0.

FIFO::
  Bypass the automatic allocation mechanism and always include
  this code in the event FIFO.

=== Database Events ===

Implimented for: event

See: evrApp/Db/evrevent.db

A device support for the 'event' recordtype is provided which
uses the Event FIFO to record the arrival of certain interesting
events.  When set to SCAN 'I/O Intr' the event record device support
will process the record causing the requested DB event.

----------------------------------------
record(event, "$(P)$(N)") {
  field(DTYP, "EVR")
  field(SCAN, "I/O Intr")
  field(INP , "@Card=$(C),Code=$(CODE)")
  field(VAL , "$(EVNT)")
}

record(calc, "$(P)$(N):count") {
  field(SCAN, "Event")
  field(CALC, "A+1")
  field(INPA, "$(P)$(N):count NPP")
  field(EVNT, "$(EVNT)")
}
----------------------------------------

In this example the hardware event code '$(CODE)' will cause the
database event '$(EVNT)'.  Note that while both '$(CODE)' and
'$(EVNT)' are numbers, they need not be the same.  Hardware
code 21 can cause DB event 40.
